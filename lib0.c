#include "lib0.h"// =================== 簡易函數 ======================void swap(int *p, int *q){    int t;    t = *p;    *p = *q;    *q = t;}inline int isid(int c){    return (c >= 'a' && c <= 'z') ||        (c >= 'A' && c <= 'Z') ||        c == '_';}inline int isnum(int c){    return c >= '0' && c <= '9';}inline int isoct(int c){    return c >= '0' && c <= '7';}inline int toup(int c){    if (c >= 'a' && c <= 'z')        return c - 'a' + 'A';    else        return c;}// ====================== Memory 記憶體函數 ===============================/* memory management */#ifdef MEM_DEBUGint mem_cur_size;int mem_max_size;unsigned malloc_usable_size(void*);#endifvoid pfree(void *ptr){#ifdef MEM_DEBUG    mem_cur_size -= malloc_usable_size(ptr);#endif    free(ptr);}void *pmalloc(unsigned long size){    void *ptr;    ptr = malloc(size);    if (!ptr && size)        error0("memory full");#ifdef MEM_DEBUG    mem_cur_size += malloc_usable_size(ptr);    if (mem_cur_size > mem_max_size)        mem_max_size = mem_cur_size;#endif    return ptr;}void *pmallocz(unsigned long size){    void *ptr;    ptr = pmalloc(size);    memset(ptr, 0, size);    return ptr;}void *prealloc(void *ptr, unsigned long size){    void *ptr1;#ifdef MEM_DEBUG    mem_cur_size -= malloc_usable_size(ptr);#endif    ptr1 = realloc(ptr, size);#ifdef MEM_DEBUG    /* NOTE: count not correct if alloc error, but not critical */    mem_cur_size += malloc_usable_size(ptr1);    if (mem_cur_size > mem_max_size)        mem_max_size = mem_cur_size;#endif    return ptr1;}/*#define free(p) use_tcc_free(p)#define malloc(s) use_tcc_malloc(s)#define realloc(p, s) use_tcc_realloc(p, s)void tcc_memstats(void){#ifdef MEM_DEBUG    printf("memory in use: %d\n", mem_cur_size);#endif}*/// ====================== String 字串函數 ===============================/* copy a string and truncate it. */char *pstrcpy(char *buf, int buf_size, const char *s){    char *q, *q_end;    int c;    if (buf_size > 0) {        q = buf;        q_end = buf + buf_size - 1;        while (q < q_end) {            c = *s++;            if (c == '\0')                break;            *q++ = c;        }        *q = '\0';    }    return buf;}/* strcat and truncate. */char *pstrcat(char *buf, int buf_size, const char *s){    int len;    len = strlen(buf);    if (len < buf_size)         pstrcpy(buf + len, buf_size - len, s);    return buf;}char *pstrdup(const char *str){    char *ptr;    ptr = pmalloc(strlen(str) + 1);    strcpy(ptr, str);    return ptr;}// 在某字串後面用 printf 補進新的尾端。void strcat_vprintf(char *buf, int buf_size, const char *fmt, va_list ap){    int len;    len = strlen(buf);    vsnprintf(buf + len, buf_size - len, fmt, ap);}void strcat_printf(char *buf, int buf_size, const char *fmt, ...){    va_list ap;    va_start(ap, fmt);    strcat_vprintf(buf, buf_size, fmt, ap);    va_end(ap);}// CString handling// ============= 字串處理 ======================void cstr_realloc(CString *cstr, int new_size){    int size;    void *data;    size = cstr->size_allocated;    if (size == 0)        size = 8; // no need to allocate a too small first string    while (size < new_size)        size = size * 2;    data = prealloc(cstr->data_allocated, size);    if (!data)        error0("memory full");    cstr->data_allocated = data;    cstr->size_allocated = size;    cstr->data = data;}// add a byteinline void cstr_ccat(CString *cstr, int ch){    int size;    size = cstr->size + 1;    if (size > cstr->size_allocated)        cstr_realloc(cstr, size);    ((unsigned char *)cstr->data)[size - 1] = ch;    cstr->size = size;}void cstr_cat(CString *cstr, const char *str){    int c;    for(;;) {        c = *str;        if (c == '\0')            break;        cstr_ccat(cstr, c);        str++;    }}// add a wide charvoid cstr_wccat(CString *cstr, int ch){    int size;    size = cstr->size + sizeof(nwchar_t);    if (size > cstr->size_allocated)        cstr_realloc(cstr, size);    *(nwchar_t *)(((unsigned char *)cstr->data) + size - sizeof(nwchar_t)) = ch;    cstr->size = size;}void cstr_new(CString *cstr){    memset(cstr, 0, sizeof(CString));}// free string and reset it to NULLvoid cstr_free(CString *cstr){    pfree(cstr->data_allocated);    cstr_new(cstr);}// XXX: unicode ?void add_char(CString *cstr, int c){    if (c == '\'' || c == '\"' || c == '\\') {        // XXX: could be more precise if char or string        cstr_ccat(cstr, '\\');    }    if (c >= 32 && c <= 126) {        cstr_ccat(cstr, c);    } else {        cstr_ccat(cstr, '\\');        if (c == '\n') {            cstr_ccat(cstr, 'n');        } else {            cstr_ccat(cstr, '0' + ((c >> 6) & 7));            cstr_ccat(cstr, '0' + ((c >> 3) & 7));            cstr_ccat(cstr, '0' + (c & 7));        }    }}// ====== 動態陣列，用來儲存符號表等的基本結構嗎？=======void dynarray_add(void ***ptab, int *nb_ptr, void *data){    int nb, nb_alloc;    void **pp;        nb = *nb_ptr;    pp = *ptab;    // every power of two we double array size    if ((nb & (nb - 1)) == 0) {        if (!nb)            nb_alloc = 1;        else            nb_alloc = nb * 2;        pp = prealloc(pp, nb_alloc * sizeof(void *));        if (!pp)            error0("memory full");        *ptab = pp;    }    pp[nb++] = data;    *nb_ptr = nb;}void dynarray_reset(void *pp, int *n){    void **p;    for (p = *(void***)pp; *n; ++p, --*n)        if (*p)            pfree(*p);    pfree(*(void**)pp);    *(void**)pp = NULL;}